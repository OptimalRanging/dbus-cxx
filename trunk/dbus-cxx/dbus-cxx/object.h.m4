dnl ***************************************************************************
dnl *   Copyright (C) 2009 by Rick L. Vinyard, Jr.                            *
dnl *   rvinyard@cs.nmsu.edu                                                  *
dnl *                                                                         *
dnl *   This file is part of the dbus-cxx library.                            *
dnl *                                                                         *
dnl *   The dbus-cxx library is free software; you can redistribute it and/or *
dnl *   modify it under the terms of the GNU General Public License           *
dnl *   version 3 as published by the Free Software Foundation.               *
dnl *                                                                         *
dnl *   The dbus-cxx library is distributed in the hope that it will be       *
dnl *   useful, but WITHOUT ANY WARRANTY; without even the implied warranty   *
dnl *   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU   *
dnl *   General Public License for more details.                              *
dnl *                                                                         *
dnl *   You should have received a copy of the GNU General Public License     *
dnl *   along with this software. If not see <http://www.gnu.org/licenses/>.  *
dnl ***************************************************************************

divert(-1)

include(template.macros.m4)

define([CREATE_METHOD],[dnl
      dnl
/**
      * Creates a method with the given signature and adds it to the default interface
      */
      template <LIST(class T_return, LOOP(class T_arg%1, [$1]))>
      DBusCxxPointer<Method<LIST(T_return, LOOP(T_arg%1, $1))> > create_method( const std::string& method_name, sigc::slot$1<LIST(T_return, LOOP(T_arg%1, $1))> slot )
      {
        if ( not m_default_interface )
        {
          this->create_interface("");
          this->set_default_interface("");
        }
        // TODO throw an error if the default interface still doesn't exist
     
        DBusCxxPointer< Method<LIST(T_return, LOOP(T_arg%1, $1))> > method;
        method = m_default_interface->create_method<LIST(T_return, LOOP(T_arg%1, $1))>(method_name);
        method->set_method( slot );
        return method;
      }
      dnl
])
    
define([CREATE_INTERFACE_METHOD],[dnl
      dnl
template <LIST(class T_return, LOOP(class T_arg%1, [$1]))>
      DBusCxxPointer<Method<LIST(T_return, LOOP(T_arg%1, $1))> > create_method( const std::string& interface_name, const std::string& method_name, sigc::slot$1<LIST(T_return, LOOP(T_arg%1, $1))> slot )
      {
        Interface::pointer interface;
        interface = this->interface(interface_name);
        if ( not interface ) interface = this->create_interface(interface_name);
        // TODO throw an error if the interface still doesn't exist
     
        DBusCxxPointer< Method<LIST(T_return, LOOP(T_arg%1, $1))> > method;
        method = interface->create_method<LIST(T_return, LOOP(T_arg%1, $1))>(method_name);
        method->set_method( slot );
        return method;
      }
      dnl
])
    

divert(0)
dnl
#ifndef DBUSCXXOBJECT_H
#define DBUSCXXOBJECT_H

#include <sigc++/sigc++.h>

#include <string>
#include <map>

#include <dbus-cxx/objectpathhandler.h>
#include <dbus-cxx/interface.h>

namespace DBus
{
  /**
   * @example calculator_server.cpp
   *
   * This example is one part of three example applications that demonstrate
   * client, server and watcher applications that use adapters and proxies
   * generated by dbus-cxx-xml2cpp from a modified dbus introspection XML
   * document.
   *
   * These three examples are:
   * <ul>
   * <li> @c calculator_server.cpp
   * <li> @c calculator_client.cpp
   * <li> @c calculator_watcher.cpp
   * </ul>
   *
   * This particular piece is the server that uses the generated Object
   * derived class to provide an adapter interface for the Calculator
   * class.
   *
   * Here is the calculator class, which by itself knows nothing of dbus:
   *
   * @include xml2cpp/calculator/calculator.h
   * @include xml2cpp/calculator/calculator.cpp
   *
   * The adapter is generated with this command:
   * @code
   * dbus-cxx-xml2cpp --xml calculator.xml --adapter -f
   * @endcode
   *
   * The modified introspection XML document is here:
   * @include xml2cpp/calculator/calculator.xml
   *
   * Here is the generated adapter:
   * @include xml2cpp/calculator/calculator_adapter.h
   *
   * And here is the server application:
   *
   */

  /**
   * @defgroup local Local Objects
   *
   * This group contains objects which are natively local and
   * provide interfaces such as methods and signals that can
   * be exported to dbus.
   */

  /**
   * @defgroup objects Objects
   */

  class Connection;

  /**
   * @ingroup local
   * @ingroup objects
   *
   * @todo TODO rethink whether it might be beneficial to have multiple connections for one object
   * 
   * @author Rick L Vinyard Jr <rvinyard@cs.nmsu.edu>
   */
  class Object: public ObjectPathHandler
  {
    protected:

      Object( const std::string& path, PrimaryFallback pf=PRIMARY );

    public:

      typedef DBusCxxPointer<Object> pointer;

      typedef std::multimap<std::string, Interface::pointer> Interfaces;

      typedef std::map<std::string, Object::pointer> Children;

      static pointer create( const std::string& path = std::string(), PrimaryFallback pf=PRIMARY );

      virtual ~Object();

      /** Extends base version to include registering signals */
      virtual bool register_with_connection(DBusCxxPointer<Connection> conn);

      const Interfaces& interfaces() const;

      /** Returns the first interface with the given name */
      Interface::pointer interface( const std::string& name ) const;

      /** Adds the interface to this object */
      bool add_interface( Interface::pointer interface );

      /**
       * Creates and adds the named interface to this object
       *
       * @return the newly created interface
       */
      Interface::pointer create_interface( const std::string& name );

FOR(0, eval(CALL_SIZE),[[CREATE_METHOD(%1)
          ]])
FOR(0, eval(CALL_SIZE),[[CREATE_INTERFACE_METHOD(%1)
          ]])
      /** Removes the first interface with the given name */
      void remove_interface( const std::string& name );

      bool has_interface( const std::string& name );

      Interface::pointer default_interface() const;

      bool set_default_interface( const std::string& new_default_name );

      void remove_default_interface();

      template <class T_return, class T_arg1=nil, class T_arg2=nil, class T_arg3=nil, class T_arg4=nil, class T_arg5=nil, class T_arg6=nil, class T_arg7=nil>
          DBusCxxPointer<signal<T_return,T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> > create_signal( const std::string& name ) {
            DBusCxxPointer<DBus::signal<T_return,T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> > sig;
            Interface::pointer iface = this->default_interface();

            if (not iface) iface = this->create_interface("");

            sig = iface->create_signal<T_return,T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(name);

            return sig;
          }

      template <class T_return, class T_arg1=nil, class T_arg2=nil, class T_arg3=nil, class T_arg4=nil, class T_arg5=nil, class T_arg6=nil, class T_arg7=nil>
      DBusCxxPointer<signal<T_return,T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> > create_signal( const std::string& iface, const std::string& name ) {
        DBusCxxPointer<DBus::signal<T_return,T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7> > sig;

        if ( not has_interface(iface) ) this->create_interface(iface);
        
        sig = this->interface(iface)->create_signal<T_return,T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>(name);

        return sig;
      }

      const Children& children() const;

      Object::pointer child(const std::string& name) const;

      bool add_child(const std::string& name, Object::pointer child);

      bool remove_child(const std::string& name);

      bool has_child(const std::string& name) const;

      /** Returns a DBus XML description of this interface */
      std::string introspect(int space_depth=0) const;

      sigc::signal<void,Interface::pointer> signal_interface_added();

      sigc::signal<void,Interface::pointer> signal_interface_removed();

      sigc::signal<void,Interface::pointer/*old default*/,Interface::pointer/*new default*/> signal_default_interface_changed();

      virtual HandlerResult handle_message( DBusCxxPointer<Connection>, Message::const_pointer );

    protected:

      Children m_children;
      
      mutable pthread_rwlock_t m_interfaces_rwlock;

      pthread_mutex_t m_name_mutex;

      Interfaces m_interfaces;

      Interface::pointer m_default_interface;

      sigc::signal<void,Interface::pointer,Interface::pointer> m_signal_default_interface_changed;

      sigc::signal<void,Interface::pointer> m_signal_interface_added;

      sigc::signal<void,Interface::pointer> m_signal_interface_removed;

      typedef std::map<Interface::pointer,sigc::connection> InterfaceSignalNameConnections;

      InterfaceSignalNameConnections m_interface_signal_name_connections;

      void on_interface_name_changed(const std::string& oldname, const std::string& newname, Interface::pointer interface);

  };

}

#endif
